The for loops steps are strictelly < n, and the operation (1 << a) | (1 << b) take in n steps in terms of turing machine, 


0000001 (a-nth bit) | 0001 (b-nth bit) = 0010001 this take in turing machine context a + b steps... a, b < n then this operation take almost elemntary n steps... the internal operations of the for loop are the same of (1 << a) | (1 << b)
now operations are in the worst case

n => (1 << a) | (1 << b)
n => while loop
internals n

then the total elementary steps (turing machine steps) are n + n * n

now, for represent a set of n elements on a turing machine need almost 0, 1, 2, 3, 4, ..., n numbers, (indexes) why?

in the minimal optimal case there (for 3 elements) is:

000_001_010_011_111_...etc (_ blanck symbol) then for n elements you need n bits n times... then the input size is n ** 2 + n blanck symbols... then complexity of my algorithm its the same of the steps needed for compute union an connect...

Its linear

QED.

NOTE:

IDEA
Turing Machine:
OR GATE
tape: 010101
1)010[1]01
2)01[1]_01 (0,1=1)
3)011_[0]1 
4)0[1]1__1 (0,1=1)
5)011__[1]
6)[1]11___ (0,1=1)
=> O(n)

For the & gate its the same, and for representing sets, not needed do (1<<a) | (1<<b) if you already take for n (3) 001, 010, 100 = 1,2,4.

Then the turing machine:
input tape is for 4 elements:
0001_0010_0100_1000_ = 20
this take n for OR + n times AND = n + n^2
4 + 16 = 20
O(n)